# -*- coding: utf-8 -*-
"""621. Task Scheduler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rtaRgcki03BQjFOqTWIZePQLkZ-vufu1
"""

import heapq
import collections

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        count = collections.Counter(tasks)
        heap = [-cnt for cnt in count.values()]

        time = 0
        q = collections.deque()

        heapq.heapify(heap)

        while heap or q:
            time +=1
            if heap:
                # update the number of that task
                # since the count of each task is negative
                # we update it by +1
                cnt = 1+heapq.heappop(heap)
                if cnt:
                    # cnt is the remaining number of that task
                    # and second parameter is the time 
                    # when that task is avaliable next time
                    q.append([cnt, time+n])
            # append the cnt back to the heap when that task is ready
            if q and q[0][1] == time:
                heapq.heappush(heap, q.popleft()[0])
        return time